// react-popup-src/src/App.jsx
import React, { useState, useEffect } from 'react';

// --- Start: IndexedDB Logic (Copied & adapted from db.js for now) ---
const DB_NAME = 'flashcardDB';
const DB_VERSION = 1;
const STORE_NAME = 'flashcards';

let dbPromise = null; // Store the promise for opening the DB

function openDB() {
    if (!dbPromise) {
        console.log(`Attempting to open DB: ${DB_NAME} version ${DB_VERSION}`);
        dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                console.log('Database upgrade needed or first-time setup.');
                const tempDb = event.target.result;
                if (!tempDb.objectStoreNames.contains(STORE_NAME)) {
                    console.log(`Creating object store: ${STORE_NAME}`);
                    tempDb.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    console.log('Object store created successfully.');
                }
            };

            request.onsuccess = (event) => {
                const db = event.target.result;
                console.log(`Database "${DB_NAME}" opened successfully (version ${db.version}).`);
                db.onerror = (errorEvent) => { // Add a generic error handler on the connection
                     console.error("Database connection error:", errorEvent.target.error);
                     dbPromise = null; // Reset promise on connection error
                };
                 // Handle closing unexpectedly
                db.onclose = () => {
                    console.warn('Database connection closed.');
                    dbPromise = null; // Allow reopening
                };
                resolve(db);
            };

            request.onerror = (event) => {
                console.error("Error opening database:", event.target.error);
                 dbPromise = null; // Reset promise on error
                reject(event.target.error);
            };

            request.onblocked = (event) => {
                 console.warn("Database open request blocked.");
                 dbPromise = null; // Reset promise on block
                 reject(new Error("Database connection blocked. Close other tabs/windows."));
            }
        });
    }
    return dbPromise;
}
// --- End: IndexedDB Logic ---


function App() {
  const [selectedText, setSelectedText] = useState('');
  const [backText, setBackText] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState('');
  const [saveStatus, setSaveStatus] = useState(''); // For save feedback

  // --- Effect for fetching selected text (same as before) ---
  useEffect(() => {
    // Make sure DB is ready when popup opens (optional, pre-opens connection)
    openDB().catch(err => {
        console.error("Initial DB open failed:", err);
        setError("Could not connect to database."); // Show DB error
    });

    // Fetch selected text
    if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
      chrome.runtime.sendMessage({ type: "GET_SELECTED_TEXT" }, (response) => {
        if (chrome.runtime.lastError) {
          console.error("Error getting selected text:", chrome.runtime.lastError.message);
          setError(`Error: ${chrome.runtime.lastError.message}`);
          setIsLoading(false);
          return;
        }
        if (response && typeof response.text === 'string') {
          setSelectedText(response.text);
        } else {
          setSelectedText('');
        }
        setIsLoading(false);
      });
    } else {
      setError("Extension environment error.");
      setIsLoading(false);
    }
  }, []);


  // --- Function to handle saving the flashcard ---
  const handleSave = async () => {
    if (!selectedText || !backText.trim()) {
      setSaveStatus('Front or back text missing.');
      return;
    }

    setSaveStatus('Saving...'); // Indicate saving process

    /*
     * Expected Flashcard Structure:
     * {
     *   id?: number, // Auto-generated by IndexedDB
     *   front: string,
     *   back: string,
     *   notes?: string,
     *   tags?: string[],
     *   hintImage?: string, // URL or maybe base64 data
     *   bucket: number // Starting bucket for Leitner system
     * }
     */
    const newFlashcard = {
        front: selectedText,
        back: backText.trim(),
        bucket: 1, // Default starting bucket
        // Add other fields like notes, tags later if needed
        createdAt: new Date().toISOString() // Optional: track creation time
    };

    try {
        const db = await openDB(); // Get the DB instance (reuses the promise)
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        const request = store.add(newFlashcard);

        request.onsuccess = () => {
            console.log('Flashcard added successfully!', request.result); // request.result is the new ID
            setSaveStatus(`Flashcard saved! (ID: ${request.result})`);
            setBackText(''); // Clear input field
            // Optionally close the popup after successful save
            // setTimeout(() => window.close(), 1500);
        };

        request.onerror = (event) => {
            console.error('Error adding flashcard:', event.target.error);
            setSaveStatus(`Error saving: ${event.target.error.message}`);
        };

        transaction.oncomplete = () => {
            console.log('Save transaction completed.');
            // Feedback already set in request.onsuccess
        };

        transaction.onerror = (event) => {
            console.error('Save transaction error:', event.target.error);
             // Don't override specific add error if already set
            if (!saveStatus.startsWith('Error')) {
                 setSaveStatus(`Transaction error: ${event.target.error.message}`);
            }
        };

    } catch (err) {
        console.error('Failed to open DB for saving:', err);
        setSaveStatus(`DB Error: ${err.message}`);
    }
  };

  // --- Render Logic ---
  if (isLoading) return <div>Loading selected text...</div>;
  // Prioritize DB connection error over text fetching error if both occurred
  if (error && error === "Could not connect to database.") return <div>Error: {error}</div>;


  return (
    <>
      <h4>Create Flashcard</h4>

      {error && error !== "Could not connect to database." && <p style={{color: 'red'}}>{error}</p>} {/* Show other errors */}

      {selectedText ? (
        <>
          <label htmlFor="flashcard-front">Front (Selected Text):</label>
          <div id="flashcard-front" className="selected-text-display">
            {selectedText}
          </div>
          <label htmlFor="flashcard-back">Back (Translation/Definition):</label>
          <textarea
            id="flashcard-back"
            rows="3"
            value={backText}
            onChange={(e) => setBackText(e.target.value)}
            placeholder="Enter the back of the flashcard..."
            disabled={saveStatus === 'Saving...'} // Disable while saving
          />
          <button
             onClick={handleSave}
             disabled={!backText.trim() || saveStatus === 'Saving...'} // Disable if back empty or saving
           >
            {saveStatus === 'Saving...' ? 'Saving...' : 'Save Flashcard'}
          </button>
          {saveStatus && <p>{saveStatus}</p>} {/* Display save status/feedback */}
        </>
      ) : (
        <p>Select text on a page first, then open this popup.</p>
      )}
    </>
  );
}

export default App;